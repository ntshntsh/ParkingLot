<div class="step-text">
<p><a class="theory-lookup not-relevant" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, null safety is a crucial feature in the language's design that addresses the issue of null references in programming, often referred to as the billion dollar mistake. | In Kotlin, types are non-nullable by default, and if you attempt to assign or return null to a non-nullable variable, the compiler will give an error. To permit a variable to carry a null value, you must declare it as nullable by adding a ? to its type. Kotlin offers several mechanisms to deal with nullable types securely, such as safe call (), elvis operator (), safe casting (), and let function.">Null safety</a> is a crucial feature in Kotlin's design, addressing the notorious 'Billion Dollar Mistake'â€”the use of null references in programming. Kotlin's <a class="theory-lookup not-relevant" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a type system is a set of rules that define the allowed types of data and operations that can be performed on them. | It is a crucial concept in statically typed languages like Kotlin, where type relationships are checked at compile time. A type defines a set of valid values within a domain and a set of appropriate and consistent operations for the established value domain. In a hierarchical relationship, a subtype is a type that is related to another type (the supertype), inheriting all its characteristics (valid values and operations), but it may also have additional values or operations or restrict the value in some way.">type system</a> aims to get rid of null references, which commonly lead to bugs and crashes in software development.</p>
<p>In Kotlin, types are non-nullable by default. If you attempt to assign or return null to a non-nullable variable, the compiler will give an error:</p>
<pre><code class="language-kotlin">var name: String = "Kotlin"
name = null // Compiler error
</code></pre>
<p>To permit a variable to carry a null value, you must declare it as nullable by adding a <code class="language-kotlin">?</code> to its type:</p>
<pre><code class="language-kotlin">var name: String? = "Kotlin"
name = null // This is fine
</code></pre>
<p>Kotlin offers several mechanisms to deal with nullable types securely:</p>
<ol><li><p><strong><a class="theory-lookup not-relevant" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a safe call is a way to call a member function or property accessor on an object that may be null, without causing a NullPointerException. | It is denoted by the `?.` syntax, which means if the object is not null, call the member function or access the property; otherwise, return null. This allows for more concise and safer code, especially when dealing with potentially null objects. It is particularly useful in situations where the object being called on may not always be initialized or may be null due to asynchronous operations or data fetching.">Safe Calls</a> (</strong><code class="language-kotlin">?.</code>): This allows you to perform operations on a nullable object only if it's not null.</p></li></ol>
<pre><code class="language-kotlin">val length = name?.length // length is null if name is null
</code></pre>
<ol><li><p><strong>Elvis Operator (</strong><code class="language-kotlin">?:</code>): It furnishes a default value if the expression to the left is null.</p></li></ol>
<pre><code class="language-kotlin">val length = name?.length ?: 0 // length is 0 if name is null
</code></pre>
<ol><li><p><strong>Non-Null Assertion (</strong><code class="language-kotlin">!!</code>): Transforms a nullable type to a <a class="theory-lookup not-relevant" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a non-nullable type is a variable that cannot hold a null value. | By default, variables in Kotlin are non-nullable. If you try to assign or return null to a non-nullable variable, the compiler will give an error. This feature helps to prevent null reference errors and makes the code more stable and easy to maintain. In contrast, a nullable type is a variable that can hold a null value. To declare a variable that can hold a null value, you append a question mark to the type.">non-nullable type</a>, throwing an exception if the value is null.</p></li></ol>
<pre><code class="language-kotlin">val length = name!!.length // Throws NullPointerException if name is null
</code></pre>
<ol><li><p><strong>Safe Casting (</strong><code class="language-kotlin">as?</code>): Safely casts to a type and returns null if the casting isn't possible.</p></li></ol>
<pre><code class="language-kotlin">val x: Any = "Kotlin"
val y: String? = x as? String // y is safely cast to String or null
</code></pre>
<p>Kotlin, by offering these tools, assists developers in averting null reference errors, making the code more stable and easy to maintain.</p>
<h5 id="understanding-nullable-types-in-kotlin">Understanding Nullable Types in Kotlin</h5>
<p>Kotlin seeks to eliminate the dreaded <code class="language-kotlin">NullPointerException</code> from our code by introducing a clear distinction between nullable and non-nullable types.</p>
<p><strong>Non-Nullable Types:</strong> By default, variables in Kotlin are non-nullable. If you try to assign or return <code class="language-kotlin">null</code> in a non-nullable variable, the compiler will give an error.</p>
<pre><code class="language-kotlin">var name: String = "Kotlin"
name = null // Compiler error
</code></pre>
<p><strong>Nullable Types:</strong> To declare a variable that can hold a <code class="language-kotlin">null</code> value, you append a question mark <code class="language-kotlin">?</code> to the type.</p>
<pre><code class="language-kotlin">var name: String? = "Kotlin"
name = null // This is fine
</code></pre>
<p>When you work with nullable types, Kotlin requires you to handle the possibility of <code class="language-kotlin">null</code> values explicitly, thereby making your code safer and more predictable.</p>
<p><strong>Safe Calls (</strong><code class="language-kotlin">?.</code>): Kotlin provides the safe call operator that allows you to access properties or call methods on nullable variables without risking a <code class="language-kotlin">NullPointerException</code>.</p>
<pre><code class="language-kotlin">val length = name?.length // length is null if name is null
</code></pre>
<p><strong>Elvis Operator (</strong><code class="language-kotlin">?:</code>): The Elvis operator allows you to provide a default value if the expression to the left is <code class="language-kotlin">null</code>.</p>
<pre><code class="language-kotlin">val length = name?.length ?: 0 // length is 0 if name is null
</code></pre>
<p><strong>Non-null Assertion (</strong><code class="language-kotlin">!!</code>): If you're absolutely certain a nullable reference isn't null, you can use the <a class="theory-lookup not-relevant" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a non-null assertion is a mechanism to handle nullable objects by throwing an exception if the value turns out to be null. | Kotlin's type system aims to eliminate null reference issues, which are a common cause of bugs and crashes in software development. By default, variables in Kotlin are non-nullable, and if you attempt to assign or return null to a non-nullable variable, the compiler will give an error. To permit a variable to carry a null value, you must declare it as nullable by adding a question mark to its type. When working with nullable types, Kotlin requires you to handle the possibility of a null value explicitly, making your code safer and more predictable.">non-null assertion</a> operator to throw an exception if the value turns out to be <code class="language-kotlin">null</code>.</p>
<pre><code class="language-kotlin">val length = name!!.length // Throws NullPointerException if name is null
</code></pre>
<p>Separated between nullable and non-nullable types, Kotlin provides a sturdy mechanism for managing <code class="language-kotlin">null</code>, making your code less vulnerable to <code class="language-kotlin">NullPointerException</code>s.</p>
<h5 id="safe-calls-and-the-elvis-operator-in-kotlin">Safe Calls and the Elvis Operator in Kotlin</h5>
<p>Kotlin targets to remove the feared <code class="language-kotlin">NullPointerException</code> from our code by bringing in null safety features. Two such features are safe calls and the Elvis operator.</p>
<h5 id="safe-calls">Safe Calls (?.)</h5>
<p>Safe calls allow you to access properties and methods of nullable objects without risk of a <code class="language-kotlin">NullPointerException</code>. When you use a safe call, Kotlin checks for null before performing the operation. If the object is null, it will return null instead of casting an exception.</p>
<p>Here's how to use a safe call:</p>
<pre><code class="language-kotlin">val name: String? = person?.name</code></pre>
<p>If <code class="language-kotlin">person</code> is not null, <code class="language-kotlin">name</code> will be assigned the value of <code class="language-kotlin">person.name</code>. If <code class="language-kotlin">person</code> is null, <code class="language-kotlin">name</code> will be null.</p>
<h5 id="the-elvis-operator">The Elvis Operator (?:)</h5>
<p>The Elvis operator lets you provide an alternative value in case the <a class="theory-lookup not-relevant" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an expression is a piece of code that evaluates to a value. | It can be a simple literal value, a variable, a function call, or a more complex combination of these elements using operators or other language constructs. Expressions are used to compute and return values from functions, assign values to variables, and perform calculations or operations in conditionals. For example, 2 \* 2 is an expression, and it produces a single value.">expression</a> to its left is null. This is particularly handy for delivering default values or resorting to a safe operation.</p>
<p>Here's an example of using the Elvis operator:</p>
<pre><code class="language-kotlin">val name: String = person?.name ?: "Unknown"</code></pre>
<p>In this case, if <code class="language-kotlin">person</code> isn't null and <code class="language-kotlin">person.name</code> isn't null, <code class="language-kotlin">name</code> will be given the value of <code class="language-kotlin">person.name</code>. If either <code class="language-kotlin">person</code> or <code class="language-kotlin">person.name</code> is null, <code class="language-kotlin">name</code> will receive the value "Unknown".</p>
<p>Using safe calls in combination with the Elvis operator provides a powerful tool for dealing with nullable types in Kotlin, reducing the risk of <code class="language-kotlin">NullPointerException</code> and making your code more concise and secure.</p>
<h5 id="the-operator-in-kotlin-use-with-caution">The <code class="language-kotlin">!!</code> Operator in Kotlin: Use With Caution</h5>
<p>Kotlin, designed to eradicate the <code class="language-kotlin">NullPointerException</code> from your code, introduces features that ensure null safety. However, the <code class="language-kotlin">!!</code> operator is an exception that reintroduces the potential for such errors. It forcefully casts a nullable type to a non-null type.</p>
<pre><code class="language-kotlin">val name: String? = null
val nonNullName: String = name!! // Throws NullPointerException
</code></pre>
<p>The <code class="language-kotlin">!!</code> operator asserts that the value is non-null, and if it's actually null, a <code class="language-kotlin">NullPointerException</code> is cast immediately. This is contrary to Kotlin's philosophy of null safety and should be used sparingly.</p>
<h5 id="why-overuse-is-problematic">Why Overuse is Problematic:</h5>
<ol><li><p><strong>Defeats Null Safety</strong>: Kotlin's type system is designed to handle nulls gracefully. Overusing <code class="language-kotlin">!!</code> bypasses these safety measures.</p></li><li><p><strong>Code Smell</strong>: Regular use often indicates a disregard for proper null checks and can lead to code that's less stable and more challenging to maintain.</p></li><li><p><strong>Unexpected Crashes</strong>: It can cause your application to crash unexpectedly if proper null checks are not done before using <code class="language-kotlin">!!</code>.</p></li></ol>
<h5 id="safer-alternatives">Safer Alternatives:</h5>
<ul><li><p><strong>Safe Calls (</strong><code class="language-kotlin">?.</code>): Returns the value if it's non-null; otherwise, returns null.</p><pre><code class="language-kotlin">val length = name?.length // Safe call, length will be null if name is null
            </code></pre></li><li><p><strong>Elvis Operator (</strong><code class="language-kotlin">?:</code>): Delivers a default value if the expression to the left is null.</p><pre><code class="language-kotlin">val length = name?.length ?: 0 // If name is null, length will be 0
            </code></pre></li><li><p><strong>Safe Casting (</strong><code class="language-kotlin">as?</code>): Safely casts to the given type or returns null if the cast isn't possible.</p><pre><code class="language-kotlin">val nullableInt: Int? = something as? Int
            </code></pre></li><li><p><strong>Let Function</strong>: Executes a block of code if the variable is not null.</p><pre><code class="language-kotlin">name?.let { 
    println("Name is $it") 
}
            </code></pre></li></ul>
<p>In conclusion, the <code class="language-kotlin">!!</code> operator should be your last option. Embrace Kotlin's null safety features to write robust, crash-resistant code.</p>
<h5 id="best-practices-for-null-safety-in-kotlin">Best Practices for Null Safety in Kotlin</h5>
<p>Kotlin's type system is designed to eliminate the danger of null references from the code, also known as the billion-dollar mistake. Here are some best practices to enforce null safety:</p>
<ol><li><p><strong>Use Nullable Types Wisely</strong>: Only use nullable types (<code class="language-kotlin">Type?</code>) when a variable can indeed be <code class="language-kotlin">null</code>. If a variable should not be <code class="language-kotlin">null</code>, use a non-nullable type.</p></li><li><p><strong>Safe Calls (</strong><code class="language-kotlin">?.</code>): Use the safe call operator when accessing properties or methods on a nullable object. This will return <code class="language-kotlin">null</code> if the object is <code class="language-kotlin">null</code> instead of throwing a <code class="language-kotlin">NullPointerException</code>.</p><pre><code class="language-kotlin">val length = nullableString?.length</code></pre></li><li><p><strong>Elvis Operator (</strong><code class="language-kotlin">?:</code>): The Elvis operator lets you to offer an alternative value if an expression evaluates to <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">val length = nullableString?.length ?: 0</code></pre></li><li><p><strong>Non-Null Assertion (</strong><code class="language-kotlin">!!</code>): Use this operator only when you are certain that the value is not <code class="language-kotlin">null</code>. It will throw a <code class="language-kotlin">NullPointerException</code> if the value is <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">val length = nullableString!!.length</code></pre></li><li><p><strong>Use </strong><code class="language-kotlin">let</code> for Null Checks: The <code class="language-kotlin">let</code> function can be used to execute block of code only if the variable is not <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">nullableString?.let {
    // Code here will only run if nullableString is not null
}</code></pre></li><li><p><strong>Use </strong><code class="language-kotlin">apply</code> for Configuration: Use <code class="language-kotlin">apply</code> on a nullable object to configure it if it's not <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">nullableObject?.apply {
    // Configure object here
}</code></pre></li><li><p><strong>Use </strong><code class="language-kotlin">takeIf</code> and <code class="language-kotlin">takeUnless</code>: These functions are useful for conditional checks that return <code class="language-kotlin">null</code> if the condition is not met.</p><pre><code class="language-kotlin">val positiveNumber = input.takeIf { it &gt; 0 }
val notBlankString = input.takeUnless { it.isBlank() }</code></pre></li><li><p><strong>Design APIs for Null Safety</strong>: When designing APIs, use default parameters and provide non-null types. This encourages API consumers to think about nullability and reduces chances of <code class="language-kotlin">NullPointerException</code>.</p><pre><code class="language-kotlin">fun process(input: String = "") { /*...*/ }</code></pre></li></ol>
<p>By following these practices and utilising Kotlin's <a class="theory-lookup not-relevant" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a standard library is a fundamental part of the Kotlin programming language that is included with the language and provides essential functionality for working with the language. | It offers a robust set of tools to handle various programming tasks efficiently, and it is designed to work seamlessly with Kotlin's language features. The standard library includes functions, classes, and methods that provide pre-built functionality, which can be invoked or used in your code, saving you the time and effort of writing these functionalities from scratch. Examples of functionalities provided by the Kotlin standard library include handling complex math calculations like the sine and cosine of an angle. Standard libraries can be categorized into those that are included with the language and provide essential functionality, and third-party libraries that offer specialized or advanced features.">standard library</a> functions, you can write more robust and null-safe code. Remember, the key to avoiding <code class="language-kotlin">NullPointerException</code> is to write code that communicates nullability explicitly and handles it gracefully.</p>
<h5 id="conclusion">Conclusion</h5>
<p>Kotlin's null safety features aim to reduce the risks associated with null references, often referred to as the "Billion Dollar Mistake". By making types non-nullable by default and providing explicit nullable types, Kotlin compels developers to handle the possibility of null values in a controlled way. Safe calls, the Elvis operator, <a class="theory-lookup not-relevant" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, safe casting is the process of converting an object of a certain type to another type in a type-safe manner. | This is achieved through the use of smart casts, which automatically cast a nullable type to a non-nullable type when it has been checked with the `is` or `!is` operator. This eliminates the need for explicit type cast operators and ensures that a `ClassCastException` is not thrown at runtime. Kotlin also provides an unsafe cast operator, represented by the `as?` keyword, which can be used to cast an object to a non-nullable type. However, if the object cannot be cast to the specified type, a `ClassCastException` will be thrown.">safe casting</a>, and the <code class="language-kotlin">let</code> function are among the tools provided by Kotlin to handle nullable types securely and prevent <code class="language-kotlin">NullPointerException</code>.</p>
</div>