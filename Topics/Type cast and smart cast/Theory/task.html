<div class="step-text">
<p><a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a type check is the process of verifying if an object belongs to a particular data type. | This is done using the `and` operator, which allows developers to check if an object is an instance of a specific type. If the object belongs to the specified type, the `and` operator returns `true`; otherwise, it returns `false`. Type checking in Kotlin is safe and easy to use because it is a statically-typed language, and any type mismatch or compile-time errors can be detected by the programmer during the development phase.">Type checks</a> and casts are essential in any programming language. Type checks allow developers to verify if an object belongs to a particular data type, while <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, type casting is the process of converting an object from one data type to another. | It is used when working with objects of different types and performing operations that require a specific type. Kotlin, being a statically-typed language, has several features that make type checking and casting easy and safe to use. The `is` and `!is` operators in Kotlin are used for type checking. They allow developers to check if an object belongs to a particular data type. The `as` keyword is used for casting an object to a different type.">type casts</a> enable programmers to convert an object from one type to another. Kotlin, being a statically-typed language, has several features that make type checks and casts easy and safe to use.</p>
<h5 id="is-and-is-operators">is and !is operators</h5>
<p>The <code class="language-kotlin">is</code> and <code class="language-kotlin">!is</code> operators in Kotlin are used for type checks. They allow developers to check if an object belongs to a particular data type. The <code class="language-kotlin">is</code> operator returns true if an object belongs to the specified type and false if it doesn't. Conversely, the <code class="language-kotlin">!is</code> operator returns true if an object doesn't belong to the specified type and false if it does.</p>
<p>For example:</p>
<pre><code class="language-kotlin">val obj: Any = "Hello, Kotlin"
if (obj is String) {
   println(obj.uppercase())
} else {
   println("obj is not a String")
}</code></pre>
<p>In the above code, we use the <code class="language-kotlin">is</code> operator to check if the <code class="language-kotlin">obj</code> variable is a <code class="language-kotlin">String</code>. If it is a <code class="language-kotlin">String</code>, we convert it to uppercase and print it. Otherwise, we print a message saying that <code class="language-kotlin">obj</code> is not a <code class="language-kotlin">String</code>. This is a good example for the <code class="language-kotlin">is</code> operator, but let's remember the idioms in Kotlin, one of the advantages of this programming language. One of the often used idioms in Kotlin is:</p>
<pre><code class="language-kotlin">when (x) {
    is Foo -&gt; ...
    is Bar -&gt; ...
    else   -&gt; ...
}</code></pre>
<p>Look at an example of how we can use that:</p>
<pre><code class="language-kotlin">fun processInput(input: Any) {
    when (input) {
        is Int -&gt; println("Input is an integer")
        is String -&gt; println("Input is a string")
        is Double -&gt; println("Input is a double")
        else -&gt; println("Unknown input")
    }
}</code></pre>
<p>In this example, the function <code class="language-kotlin">processInput</code> takes an argument of type <code class="language-kotlin">Any</code>, which means it can accept any type of object. Within the function, we use <code class="language-kotlin">when</code> with <code class="language-kotlin">is</code> to check the type of the input object. Depending on the type, we print a message indicating what type of input it is. If the input object is not one of the expected types, we print the "Unknown input" message.</p>
<h5 id="smart-casts">Smart casts</h5>
<p>Kotlin also has a feature known as <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, smart cast is a feature that simplifies code when working with nullable types. | When a nullable type is checked using the `is` operator, Kotlin automatically casts the object to a non-nullable type. This means that you don't need to use any type cast operator. Smart cast can make your code more concise and easier to read. However, it's important to note that smart cast only works when the type is checked using the `is` operator. If you need to perform a type cast in other situations, you can use the unsafe cast operator, represented by the `as?` keyword.">smart casts</a>. Smart casts are used to simplify code when working with nullable types. When a nullable type is checked with the <code class="language-kotlin">is</code> operator, Kotlin automatically casts the object to a <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a non-nullable type is a variable that cannot hold a null value. | By default, variables in Kotlin are non-nullable. If you try to assign or return null to a non-nullable variable, the compiler will give an error. This feature helps to prevent null reference errors and makes the code more stable and easy to maintain. In contrast, a nullable type is a variable that can hold a null value. To declare a variable that can hold a null value, you append a question mark to the type.">non-nullable type</a>.</p>
<p>For example:</p>
<pre><code class="language-kotlin">fun printLength(obj: Any) {
   if (obj is String) {
      println(obj.length)
   }
}</code></pre>
<p>In the above code, we check if the <code class="language-kotlin">obj</code> variable is a <code class="language-kotlin">String</code> by using the <code class="language-kotlin">is</code> operator. If it is a <code class="language-kotlin">String</code>, we print its length. Since Kotlin automatically casts the <code class="language-kotlin">obj</code> variable to a non-nullable type, we don't need to use any type cast operator.</p>
<h5 id="unsafe-cast-operator">"Unsafe" cast operator</h5>
<p>Kotlin has an unsafe cast operator, which is represented by the <code class="language-kotlin">as</code> <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a keyword is a word that has a special meaning in the language and cannot be changed by the programmer. | It is used to define the structure and behavior of the code. Examples of keywords in Kotlin include `fun` (used to define a function), `var` (used to define a variable), and `if` (used to define a conditional statement). Keywords are reserved words in Kotlin and cannot be used as identifiers.">keyword</a>. The <code class="language-kotlin">as</code> keyword is used to cast an object to a non-nullable type. If the object cannot be cast to the specified type, the <code class="language-kotlin">as</code> operator throws a ClassCastException.</p>
<p>For example:</p>
<pre><code class="language-kotlin">val obj: Any = "Hello, Kotlin"
val str: String = obj as String // Unsafe cast operator
println(str.uppercase())</code></pre>
<p>In the above code, we use the <code class="language-kotlin">as</code> operator to cast the <code class="language-kotlin">obj</code> variable to a <code class="language-kotlin">String</code>. If <code class="language-kotlin">obj</code> is not a <code class="language-kotlin">String</code>, the <code class="language-kotlin">as</code> operator throws a ClassCastException.</p>
<h5 id="safe-nullable-cast-operator">"Safe" (nullable) cast operator</h5>
<p>Kotlin also has a safe cast operator, which is represented by the <code class="language-kotlin">as?</code> keyword. The <code class="language-kotlin">as?</code> operator is used to cast an object to a nullable type. If the object cannot be cast to the specified type, the <code class="language-kotlin">as?</code> operator returns <code class="language-kotlin">null</code>.</p>
<p>For example:</p>
<pre><code class="language-kotlin">fun main() {
    val obj: Any = 123
    val str: String? = obj as? String // Safe (nullable) cast operator
    if (str != null) {
        println(str.uppercase())
    }
}</code></pre>
<p>In the above code, we use the <code class="language-kotlin">as?</code> operator to cast the <code class="language-kotlin">obj</code> variable to a <code class="language-kotlin">String</code>. Since <code class="language-kotlin">obj</code> is not a <code class="language-kotlin">String</code>, the <code class="language-kotlin">as?</code> operator returns <code class="language-kotlin">null</code>. Therefore, the <code class="language-kotlin">println</code> <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a statement is a single command to be executed, such as printing a text or assigning a value to a variable. | Unlike expressions, which produce a single value as a result of computation, statements are standalone commands that have a side effect, like changing the state of the program. The result of a statement is not used in the program, whereas the result of an expression often is. For example, in the statement `val x = 2 * 2`, the expression `2 * 2` is evaluated, and its result is assigned to the variable `x`. However, the result of the statement itself is not used in the program. In contrast, if you write `println(2 * 2)`, the expression `2 * 2` is evaluated, and its result is passed directly to the `println` function, which then prints the result. It's important to note that a statement can be an expression, but not all expressions are statements. For instance, `2 * 2` is an expression, but it's not a statement because it doesn't change the state of the program.">statement</a> doesn't print anything.</p>
<h5 id="generics-type-checks-and-casts">Generics type checks and casts</h5>
<p>In Kotlin, we can use type checks and casts with generics as well. When working with generics, we may need to check whether an object is an instance of a specific type parameter or cast it to a <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a type parameter is a named type that is used in a class, interface, or function declaration to make it work with different data types. | Type parameters are often used in generic programming, which allows for versatility and reusability of code. They are typically named using a single letter, such as T, E, K, or V, to distinguish them from regular class names. When creating an instance of a generic class, you need to provide a concrete type as a type argument, which can be inferred by the compiler if it's a standard type. Once the type argument is specified, you can invoke methods of the class using the provided type. If the class has multiple type parameters, you should specify them in order. Type parameters can be used as ordinary types inside the class body, such as a type for a field, constructor argument type, instance method argument, or return type.">type parameter</a>.</p>
<p>To check whether an object is an instance of a specific type parameter, we can use the <code class="language-kotlin">is</code> operator with the type parameter in <a class="theory-lookup not-relevant" href="/learn/step/26453" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, angle brackets &lt; &gt; are used to specify type parameters in the context of generic programming. | When defining or calling a generic method or generic extension function, you need to specify the type parameter inside the angle brackets. This allows for flexibility and optimization of code, as it enables the same function to work with different data types. It is important to note that angle brackets should not be confused with other uses of brackets in Kotlin, such as square brackets for arrays or set notation.">angle brackets</a>. For example:</p>
<pre><code class="language-kotlin">fun &lt;T&gt; exampleFunction(obj: Any) {
    if (obj is T) {
        // obj is an instance of type parameter T
    } else {
        // obj is not an instance of type parameter T
    }
}</code></pre>
<p>Similarly, we can cast an object to a type parameter using the <code class="language-kotlin">as</code> operator with the type parameter in angle brackets. However, if the object is not an instance of the type parameter, <code class="language-kotlin">ClassCastException</code> will be thrown. To avoid this, we can use the safe cast operator <code class="language-kotlin">as?</code>, which returns <code class="language-kotlin">null</code> if the cast is not possible.</p>
<pre><code class="language-kotlin">fun &lt;T&gt; exampleFunction(obj: Any) {
    val tObj: T? = obj as? T
    if (tObj != null) {
        // obj can be safely cast to type parameter T
    } else {
        // obj cannot be cast to type parameter T
    }
}</code></pre>
<p>It's important to note that type erasure occurs with generics in Kotlin, meaning that the actual type of a generic object is not known at runtime. Therefore, certain operations, like creating a new instance of a type parameter or checking if a type parameter is a subtype of another class, are not possible.</p>
<p>In summary, type checks and casts with generics in Kotlin can be done using the <code class="language-kotlin">is</code> and <code class="language-kotlin">as</code> operators with the type parameter in angle brackets, and the safe cast operator <code class="language-kotlin">as?</code> can be used to avoid <code class="language-kotlin">ClassCastException</code>s. However, certain operations may not be possible due to type erasure.</p>
<h5 id="conclusion">Conclusion</h5>
<p>In conclusion, type cast and smart cast are important features in Kotlin, which allow checking and casting objects to different types. They are useful when working with objects of different types and performing operations that require a specific type. Now let's move on to practice to better remember this topic.</p>
</div>